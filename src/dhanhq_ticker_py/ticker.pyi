from .utils import AttrDict, Callback
from _typeshed import Incomplete
from datetime import datetime as dtdt
from polars import DataFrame
from typing import Any, Callable, Dict, List, Literal, Optional, Set, Tuple
from websockets.client import WebSocketClientProtocol
from websockets.typing import Data

class DhanTicker:
    PING_INTERVAL: float
    MAXDELAY: int
    MAXRETRIES: int
    CONNECT_TIMEOUT: int
    CLOSE_TIMEOUT: int
    SUBSCRIBE: str
    UNSUBSCRIBE: str
    FULL: str
    QUOTE: str
    BROKER_CODE: str
    APP_ID: str
    APP_VERSION: str
    ROLE: str
    SOURCE: str
    WEB_VERSION: str
    PASS_TYPE: str
    SALT: str
    PBKDF2_HMAC_HASH: str
    PASS_TEXT: str
    SALT_HEX: str
    IV_HEX: str
    KEY_SIZE: int
    ITERATIONS: int
    USER_AGENT: str
    LOGIN_ACCEPT: str
    LOGIN_CONTENT_TYPE: str
    LOGIN_AUTHORISATION: str
    PING_PAYLOAD: bytes
    URL: AttrDict
    RETURN_TYPE: Set[str]
    MARKET_STATUS_BY_CODE: Dict[int, str]
    BYTE_FORMAT: AttrDict
    ON_TICK: str
    ON_ORDER_UPDATE: str
    CLOUDFLARE_DNS: List[str]
    GOOGLE_DNS: List[str]
    DNS_CACHE_SECONDS: int
    @staticmethod
    def get_signal_r_seg(exchange: str, segment: str) -> int: ...
    @staticmethod
    def market_status_by_code(status_code: int) -> Optional[str]: ...
    @staticmethod
    def get_seg_key_n_decimal_points(idx: str, sec_id: str) -> AttrDict: ...
    @staticmethod
    def process_order_packet(packet: bytes) -> Dict[str, Any]: ...
    @staticmethod
    def on_open_send_this_packet(
        id: str, token: str, client_id: str, broker_code: str, prev_day: bool = ...
    ) -> bytes: ...
    @staticmethod
    def send_getmarketstatus_frame(id: str, token: str) -> bytes: ...
    @staticmethod
    def send_heartbeat_frame(id: str, token: str) -> bytes: ...
    @staticmethod
    def get_ws_send_frames_code(
        instrument: AttrDict, message_type: str = ..., mode: str = ...
    ) -> int: ...
    @staticmethod
    def get_ws_send_frames(
        id: str,
        token: str,
        instruments: List[AttrDict],
        message_type: str = ...,
        mode: str = ...,
    ) -> List[bytes]: ...
    @staticmethod
    def update_oi(packet: bytes) -> int: ...
    @staticmethod
    def ltp_bind(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[float, int, int, float, int, dtdt, dtdt]: ...
    @staticmethod
    def update_mbp(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[List[Dict[str, int | float]], List[Dict[str, int | float]]]: ...
    @staticmethod
    def update_ohlc(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[float, float, float, float]: ...
    @staticmethod
    def bind_index_bc(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[float, float, float, float, float, dtdt, float, float]: ...
    @staticmethod
    def update_top_bid_ask(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[int, int, int, int, float, float, int, int, int]: ...
    @staticmethod
    def update_mkt_status(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[str | bytes, float, str | None]: ...
    @staticmethod
    def prev_close_bind(seg_key: AttrDict, packet: bytes) -> Tuple[float, float]: ...
    @staticmethod
    def update_ckt_limit(seg_key: AttrDict, packet: bytes) -> Tuple[float, float]: ...
    @staticmethod
    def update_52week_hl_bind(
        seg_key: AttrDict, packet: bytes
    ) -> Tuple[float, float]: ...
    @staticmethod
    def calc_chg_chgprcnt(
        seg_key: AttrDict, current: int | float, prev: int | float
    ) -> Tuple[int | float, int | float]: ...
    @staticmethod
    def generate_key(
        salt: bytes, password: bytes, key_size: int, iterations: int
    ) -> bytes: ...
    @staticmethod
    def encrypt_aes_cbc_256(
        text_to_cipher: str, key_bytes: bytes, iv: bytes
    ) -> bytes: ...
    @staticmethod
    def decrypt_aes_cbc_256(ciphered_text: str, key: bytes, iv: bytes) -> bytes: ...
    @staticmethod
    def decode_user_data(
        ciphered_text: str, return_as: Literal["bytes", "dict", "str", "attrdict"] = ...
    ) -> bytes | str | Dict[str, Any]: ...
    @staticmethod
    def encrypt_data(text_to_cipher: str, return_as: str = ...) -> str | bytes: ...
    @staticmethod
    def getWSHashApi(client_id: str, prev_day: bool = ...) -> str: ...
    @staticmethod
    def default_callbacks() -> Dict[str, Optional[Callable]]: ...
    def __aenter__(self) -> DhanTicker: ...
    def __enter__(self) -> DhanTicker: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def __del__(self) -> None: ...
    def __delete__(self) -> None: ...
    debug: Incomplete
    debug_verbose: Incomplete
    log_level: Incomplete
    callbacks: Incomplete
    on_tick: Incomplete
    on_order_update: Incomplete
    should_run: bool
    stop_stream_queue: Incomplete
    price_feed_url: Incomplete
    order_feed_url: Incomplete
    subscribed_tokens: Incomplete
    market_status: Incomplete
    def __init__(
        self,
        userdata: Optional[str] = ...,
        debug: bool = ...,
        debug_verbose: bool = ...,
        callbacks: Optional[Dict[str, Callback | Callable]] = ...,
    ) -> None: ...
    userdata: Incomplete
    def login_with_userdata(self, userdata: str) -> None: ...
    def login_with_credentials(self, login_id: str | int, password: str) -> None: ...
    def get_origin(self, endpoint: str, order_feed: bool = ...): ...
    async def get_ws_client(
        self, order_feed: bool = ...
    ) -> WebSocketClientProtocol: ...
    run_future: Incomplete
    def run(self) -> None: ...
    def stop(self) -> None: ...
    async def start_ws(self) -> None: ...
    async def stop_ws(self) -> None: ...
    async def close(self, with_exceptions: bool = ...) -> None: ...
    price_feed: Incomplete
    price_feed_running: bool
    order_feed: Incomplete
    order_feed_running: bool
    async def connect(self) -> None: ...
    async def run_forever(self) -> None: ...
    async def ping(self, order_feed: bool = ...) -> None: ...
    async def consume(self, order_feed: bool = ...) -> None: ...
    async def cast(
        self,
        to: Literal["ON_TICK", "ON_ORDER_UPDATE"],
        data: Data | Dict[str, Any] | List[AttrDict] | List[Dict[str, Any]],
    ): ...
    async def dispatch(self, data: Data, order_feed: bool = ...) -> None: ...
    async def process_order_frame(self, frame: Data) -> None: ...
    def subscribe(
        self, instruments: List[str] | List[Dict[str, Any]] | DataFrame, mode: str = ...
    ) -> None: ...
    def unsubscribe(
        self, instruments: List[str] | List[Dict[str, Any]] | DataFrame, mode: str = ...
    ) -> None: ...
    async def send_heartbeat_to_price_feed(self) -> None: ...
    async def process_price_frame(self, frame: Data) -> None: ...
    async def process_price_packet(self, packet: bytes) -> None: ...
